<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.vocabulary.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to vocabulary</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont-app</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vocabulary</span></div></div></li><li class="depth-3 branch current"><a href="ont-app.vocabulary.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="ont-app.vocabulary.format.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>format</span></div></a></li><li class="depth-3 branch"><a href="ont-app.vocabulary.linguistics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linguistics</span></div></a></li><li class="depth-3 branch"><a href="ont-app.vocabulary.lstr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lstr</span></div></a></li><li class="depth-3"><a href="ont-app.vocabulary.wikidata.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wikidata</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-*exceptional-iri-str-re*"><div class="inner"><span>*exceptional-iri-str-re*</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-as-kwi"><div class="inner"><span>as-kwi</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-as-qname"><div class="inner"><span>as-qname</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-as-uri-string"><div class="inner"><span>as-uri-string</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-clear-caches.21"><div class="inner"><span>clear-caches!</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-all-ns"><div class="inner"><span>cljc-all-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-find-ns"><div class="inner"><span>cljc-find-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-find-prefixes"><div class="inner"><span>cljc-find-prefixes</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-get-ns-meta"><div class="inner"><span>cljc-get-ns-meta</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-ns-aliases"><div class="inner"><span>cljc-ns-aliases</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-ns-map"><div class="inner"><span>cljc-ns-map</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-put-ns-meta.21"><div class="inner"><span>cljc-put-ns-meta!</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-collect-prefixes"><div class="inner"><span>collect-prefixes</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-default-on-no-kwi-ns"><div class="inner"><span>default-on-no-kwi-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-default-on-no-ns"><div class="inner"><span>default-on-no-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-escape-slash"><div class="inner"><span>escape-slash</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-get-ns-meta"><div class="inner"><span>get-ns-meta</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-iri-for"><div class="inner"><span>iri-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-keyword-for"><div class="inner"><span>keyword-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-kwi-missing-namespace-if-not-urn-or-arn"><div class="inner"><span>kwi-missing-namespace-if-not-urn-or-arn</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-namespace-re"><div class="inner"><span>namespace-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-namespace-to-ns"><div class="inner"><span>namespace-to-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-ns-to-namespace"><div class="inner"><span>ns-to-namespace</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-ns-to-prefix"><div class="inner"><span>ns-to-prefix</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-on-duplicate-prefix"><div class="inner"><span>on-duplicate-prefix</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-ordinary-iri-str-re"><div class="inner"><span>ordinary-iri-str-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefix-re-str"><div class="inner"><span>prefix-re-str</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefix-to-namespace-uri"><div class="inner"><span>prefix-to-namespace-uri</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefix-to-ns"><div class="inner"><span>prefix-to-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefixed-ns"><div class="inner"><span>prefixed-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prepend-prefix-declarations"><div class="inner"><span>prepend-prefix-declarations</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-put-ns-meta.21"><div class="inner"><span>put-ns-meta!</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-qname-for"><div class="inner"><span>qname-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-qname-re"><div class="inner"><span>qname-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-Resource"><div class="inner"><span>Resource</span></div></a></li><li class="depth-2"><a href="ont-app.vocabulary.core.html#var-resource-class"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>resource-class</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-sparql-prefixes-for"><div class="inner"><span>sparql-prefixes-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-terms"><div class="inner"><span>terms</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-unescaped-slash-re"><div class="inner"><span>unescaped-slash-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-uri-for"><div class="inner"><span>uri-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-uri-str-for"><div class="inner"><span>uri-str-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-vann-annotated-objects"><div class="inner"><span>vann-annotated-objects</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.vocabulary.core</h1><div class="doc"><pre class="plaintext">Defines utilities and a set of namespaces for commonly used linked data 
constructs, metadata of which specifies RDF namespaces, prefixes and other 
details.</pre></div><div class="public anchor" id="var-*exceptional-iri-str-re*"><h3>*exceptional-iri-str-re*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">A regex matching an IRI string which doesn't match the usual http//-ish scheme, such as `urn:`.
</pre></div></div><div class="public anchor" id="var-as-kwi"><h3>as-kwi</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns keyword identifier for an instance of Resource.
- Signature: [this] -&gt; `kwi`.
- Where:
  - `this` is an instance of RESOURCE
  - `kwi` conforms to :voc/kwi-spec</pre></div></div><div class="public anchor" id="var-as-qname"><h3>as-qname</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns a qname for instance of Resource.
- Signature: [this] -&gt; `qname`
- Where
  - `this` is an instance of `Resource`
  - `qname` conforms to `:voc/qname-spec`</pre></div></div><div class="public anchor" id="var-as-uri-string"><h3>as-uri-string</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns URI string for instance of Resource.
- Signature: [this] -&gt; `uri-string`
- Where
  - `this` is a Resource
  - `uri-string` conforms to `:voc/uri-str-spec`</pre></div></div><div class="public anchor" id="var-clear-caches.21"><h3>clear-caches!</h3><div class="usage"><code>(clear-caches!)</code></div><div class="doc"><pre class="plaintext">Side-effects: resets all caches in voc/ to nil
NOTE: call this when you may have imported new namespace metadata</pre></div></div><div class="public anchor" id="var-cljc-all-ns"><h3>cljc-all-ns</h3><div class="usage"><code>(cljc-all-ns)</code></div><div class="doc"><pre class="plaintext">Returns (`ns-name-or-obj` ...)
Where
  - `ns-name-or-obj` may either be a namespace (in clj) 
     or the name of a namespace (in cljs)</pre></div></div><div class="public anchor" id="var-cljc-find-ns"><h3>cljc-find-ns</h3><div class="usage"><code>(cljc-find-ns ns')</code></div><div class="doc"><pre class="plaintext">Returns `ns-name-or-obj` for `ns'`, or nil.
Where 
  - `ns-name-or-obj` may either be a namespace (in clj) 
    or the name of a namespace (in cljs)
  - `_ns` is a symbol which may name a namespace.
NOTE: Implementations involving cljs must use cljs-put/get-ns-meta to declare
  ns metadata.</pre></div></div><div class="public anchor" id="var-cljc-find-prefixes"><h3>cljc-find-prefixes</h3><div class="usage"><code>(cljc-find-prefixes re-str s)</code></div><div class="doc"><pre class="plaintext">Returns #{`prefix`...} for `s` matching `re-str`
Where
  - `prefix` is a prefix found in `s`, for which some (meta ns) has a 
     :vann/preferredNamespacePrefix declaration
  - `re-str` is a regex string
  - `s` is a string, typically a SPARQL query body for which we want to 
    infer prefix declarations.</pre></div></div><div class="public anchor" id="var-cljc-get-ns-meta"><h3>cljc-get-ns-meta</h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated. Use get-ns-meta
</pre></div></div><div class="public anchor" id="var-cljc-ns-aliases"><h3>cljc-ns-aliases</h3><div class="usage"><code>(cljc-ns-aliases)</code></div><div class="doc"><pre class="plaintext">Returns {`alias` `ns`, ...}
Where
  - `alias` is a symbol
  - `ns` is its associated ns in the current lexical environment.
NOTE: cljs will require explicit maintenance of *alias-map*
This is really only necessary if you're importing a package
as some symbol other than the preferred prefix.</pre></div></div><div class="public anchor" id="var-cljc-ns-map"><h3>cljc-ns-map</h3><div class="usage"></div><div class="doc"><pre class="plaintext">mimics behavior of `ns-map` on cljs, but returns empty symbol-&gt;binding map
</pre></div></div><div class="public anchor" id="var-cljc-put-ns-meta.21"><h3>cljc-put-ns-meta!</h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated. Use put-ns-meta!
</pre></div></div><div class="public anchor" id="var-collect-prefixes"><h3>collect-prefixes</h3><div class="usage"><code>(collect-prefixes acc next-ns)</code></div><div class="doc"><pre class="plaintext">Returns {`prefix` `namespace` ...} s.t. `next-ns` is included
Where
- `acc` := {`prefix` `namespace` ...}
- `next-ns` is typically an element in a reduction sequence of ns's
- `prefix` is a prefix declared in the metadata of `next-ns`
- `namespace` is a URI namespace declared for `prefix` in metadata of `next-ns`</pre></div></div><div class="public anchor" id="var-default-on-no-kwi-ns"><h3>default-on-no-kwi-ns</h3><div class="usage"><code>(default-on-no-kwi-ns kw)</code></div><div class="doc"><pre class="plaintext">Returns the name-string of `kw` if its name string is a typical URI or URN, otherwise throws a :NoIRIForKw error.
- Where:
  - `kw` is a keyword with no namespace.</pre></div></div><div class="public anchor" id="var-default-on-no-ns"><h3>default-on-no-ns</h3><div class="usage"><code>(default-on-no-ns _uri kw)</code></div><div class="doc"><pre class="plaintext">Returns the kwi normally appropriate for `kw` in cases where no ns can be matched, as is the case with say http://...
- Where
  - _uri is a dummy provided to conform to the expected function signature.
  - `kw` is either a keyword or a string (which will be read into a keyword)</pre></div></div><div class="public anchor" id="var-escape-slash"><h3>escape-slash</h3><div class="usage"><code>(escape-slash s)</code></div><div class="doc"><pre class="plaintext">Replaces a slash in `s` with a backslash-escaped slash
</pre></div></div><div class="public anchor" id="var-get-ns-meta"><h3>get-ns-meta</h3><div class="usage"><code>(get-ns-meta ns')</code><code>(get-ns-meta)</code></div><div class="doc"><pre class="plaintext">Returns `metadata` assigned to ns named `ns'`
Where
- `ns'` names a namespace or a 'dummy' namespace whose sole purpose is to hold metadata.
- `metadata` := {`key` `value`, ...}
- `key` is a keyword containing vocabulary metadata, e.g. :vann/preferredNamespacePrefix</pre></div></div><div class="public anchor" id="var-iri-for"><h3>iri-for</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Alias of uri-for
</pre></div></div><div class="public anchor" id="var-keyword-for"><h3>keyword-for</h3><div class="usage"><code>(keyword-for uri)</code><code>(keyword-for on-no-ns uri)</code></div><div class="doc"><pre class="plaintext">Returns a keyword equivalent of `uri`, properly prefixed if Vann declarations exist in some ns in the current lexical environment.
- Side effects per `on-no-ns`
- Where
  - `uri` is a string representing a URI
  - `on-no-ns` (optional) := fn [uri kw] -&gt; kwi',
     possibly with side-effects in response to the fact that no qname was found for
     `uri` (default returns `kw`)
- NOTE: typically `on-no-ns` would log a warning or make an assertion.</pre></div></div><div class="public anchor" id="var-kwi-missing-namespace-if-not-urn-or-arn"><h3>kwi-missing-namespace-if-not-urn-or-arn</h3><div class="usage"><code>(kwi-missing-namespace-if-not-urn-or-arn kw)</code></div><div class="doc"><pre class="plaintext">Returns the name-stiring of `kw`, or throws ::NoIRIForKw if `kw` is incorrectly missing a namespace.
</pre></div></div><div class="public anchor" id="var-namespace-re"><h3>namespace-re</h3><div class="usage"><code>(namespace-re)</code></div><div class="doc"><pre class="plaintext">Returns a regex to recognize substrings matching a URI for an ns declared with LOD metadata.
- Note: Groups for namespace and value.</pre></div></div><div class="public anchor" id="var-namespace-to-ns"><h3>namespace-to-ns</h3><div class="usage"><code>(namespace-to-ns)</code></div><div class="doc"><pre class="plaintext">returns {`namespace` `ns` ...} for each `ns` with :vann/preferredNamespaceUri
declaration
- Where
  - `namespace` is the URI suitable for for an RDF prefix declaration
  - `ns` is either a clojure ns (clj) or a symbol naming a clojure ns (cljs).</pre></div></div><div class="public anchor" id="var-ns-to-namespace"><h3>ns-to-namespace</h3><div class="usage"><code>(ns-to-namespace ns')</code></div><div class="doc"><pre class="plaintext">Returns `iri` for `ns`
- Where
  - `ns'` is an instance of clojure.lang.Namespace (in clj) or a symbol-name for ns (cljs)
  - `iri` is an iri declared with :vann/preferredNamespaceUri in the metadata for 
    `ns'`, or nil</pre></div></div><div class="public anchor" id="var-ns-to-prefix"><h3>ns-to-prefix</h3><div class="usage"><code>(ns-to-prefix ns')</code></div><div class="doc"><pre class="plaintext">Returns the prefix associated with `ns'`
- Where
  - `ns'` is a clojure namespace, which may have :vann/preferredNamespacePrefix
    declaration in its metadata.</pre></div></div><div class="public anchor" id="var-on-duplicate-prefix"><h3>on-duplicate-prefix</h3><div class="usage"><code>(on-duplicate-prefix prefixes prefix ns')</code></div><div class="doc"><pre class="plaintext">Throws an error if a prefix is bound to more than one namespace.
Reduces into `prefix` argument
- Where
  - `prefixes` := {`prefix` `ns`, ...}
  - `prefix` := is a string naming the `vann:preferredNamespaceUri` for `ns'`
  - `ns'` refers to a namespace
NOTE: Can be overridden with `with-redefs`.</pre></div></div><div class="public anchor" id="var-ordinary-iri-str-re"><h3>ordinary-iri-str-re</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A regex matching a standard IRI string.
</pre></div></div><div class="public anchor" id="var-prefix-re-str"><h3>prefix-re-str</h3><div class="usage"><code>(prefix-re-str)</code></div><div class="doc"><pre class="plaintext">Returns a regex string that recognizes prefixes declared in ns metadata with `:vann/preferredNamespacePrefix` keys. 
- NOTE: this is a string because the actual re-pattern will differ per clj/cljs.</pre></div></div><div class="public anchor" id="var-prefix-to-namespace-uri"><h3>prefix-to-namespace-uri</h3><div class="usage"><code>(prefix-to-namespace-uri prefix)</code></div><div class="doc"><pre class="plaintext">returns `namespace` URI associated with `prefix`
- Where:
  - `prefix` is a string declared for `ns` with vann/preferredNamespacePrefix
  - `namespace` is a string declared for some `ns` with vann/preferredNamespaceUri</pre></div></div><div class="public anchor" id="var-prefix-to-ns"><h3>prefix-to-ns</h3><div class="usage"><code>(prefix-to-ns)</code></div><div class="doc"><pre class="plaintext">Returns {`prefix` `ns` ...}
- Where
  - `prefix` is declared in metadata for some `ns` with
     :vann/preferredNamespacePrefix
  - `ns` is an instance of clojure.lang.ns available within the lexical
     context in which the  call was made.</pre></div></div><div class="public anchor" id="var-prefixed-ns"><h3>prefixed-ns</h3><div class="usage"><code>(prefixed-ns prefix)</code></div><div class="doc"><pre class="plaintext">Returns nil or the ns whose `prefix` was declared in metadata with `:vann/preferredNamespacePrefix`.
- Where
  - `prefix` is a string, typically parsed from a keyword.</pre></div></div><div class="public anchor" id="var-prepend-prefix-declarations"><h3>prepend-prefix-declarations</h3><div class="usage"><code>(prepend-prefix-declarations sparql-string)</code></div><div class="doc"><pre class="plaintext">Returns `sparql-string`, prepended with appropriate PREFIX decls.
- Where
  - `sparql-string` is a string of SPARQL, typically without prefixes.</pre></div></div><div class="public anchor" id="var-put-ns-meta.21"><h3>put-ns-meta!</h3><div class="usage"><code>(put-ns-meta! ns' m)</code><code>(put-ns-meta! m)</code></div><div class="doc"><pre class="plaintext">Side-effect: ensures that subsequent calls to (cljc-get-ns-meta `ns'` return `m`
Where
- `ns'`  is an ns(clj only) or the name of a namespace, possibly declared for the sole purpose of holding vocabulary metadata (e.g. rdf, foaf, etc)
- `m` := {`key` `value`, ...}, metadata (clj) or 'pseudo-metadata' (cljs)
- `key` is a keyword containing vocabulary metadata, e.g.
  `::vann/preferredNamespacePrefix`
NOTE: In cljs, ns's are not available at runtime, so the metadata is stored
  in an atom called 'voc/cljs-ns-metadata'
See also declarations for ont-app.vocabulary.rdf, ont-app.vocabulary.foaf, etc.
for examples of namespaces declared solely to hold vocabulary metadata.</pre></div></div><div class="public anchor" id="var-qname-for"><h3>qname-for</h3><div class="usage"><code>(qname-for kw)</code></div><div class="doc"><pre class="plaintext">Returns the 'qname' URI for `kw`, or &lt;...&gt;'d full URI if no valid qname could be found.
- Throws an error if the prefix is specified, but can't be mapped to metadata.
- Where
  - `kw` is a keyword, in a namespace with LOD declarations in its metadata.</pre></div></div><div class="public anchor" id="var-qname-re"><h3>qname-re</h3><div class="usage"><code>(qname-re)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-Resource"><h3>Resource</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Declare a `resource-class` to dispatch `as-kwi` `as-uri-string` `as-qname` methods
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-resource-class"><h3>resource-class</h3><div class="usage"><code>(resource-class this)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div></div><div class="public anchor" id="var-sparql-prefixes-for"><h3>sparql-prefixes-for</h3><div class="usage"><code>(sparql-prefixes-for sparql-string)</code></div><div class="doc"><pre class="plaintext">Returns [`prefix-string`...] for each prefix identified in `sparql-string`.
- Where
  - `sparql-string` is a string of SPARQL, typically without prefixes
  - `prefix-string` := PREFIX `prefix`: `namespace`

  - `prefix` is a prefix defined for `namespace` in metadata of some ns with 
     `:vann/preferredNamespacePrefix`
  - `namespace` is a namespace defined in the metadata for some ns with 
    `:vann/preferredNamespaceUri`</pre></div></div><div class="public anchor" id="var-terms"><h3>terms</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Describes vocabulary for this namespace. May be read into an IGraph downstream.
</pre></div></div><div class="public anchor" id="var-unescaped-slash-re"><h3>unescaped-slash-re</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Matches a string preceded by a backslash escape
</pre></div></div><div class="public anchor" id="var-uri-for"><h3>uri-for</h3><div class="usage"><code>(uri-for kw)</code><code>(uri-for on-no-kwi-ns kw)</code></div><div class="doc"><pre class="plaintext">Returns `iri` for `kw` based on metadata attached to `ns` Alias of `iri-for` or `on-no-prefix (kw) if the keyword is not namespaced.
- Where
  - `kw` is a keyword of the form `prefix`:`value`
  - `on-no-kwi-ns` := fn [kw] -&gt; uri, for cases where `kw` is not namespaced
    default is `default-on-no-kwi-ns`
  - `iri` is of the form `namespace``value`
  - `ns` is an instance of clojure.lang.ns
  - `prefix` is declared with :vann/preferredNamespacePrefix in metadata of `ns`
  - `namespace` is typically of the form http://...., declared with 
    `:vann/preferredNamespaceUri` in metadata of `ns`</pre></div></div><div class="public anchor" id="var-uri-str-for"><h3>uri-str-for</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated. Use Resource protocol and `as-uri-string` instead.
</pre></div></div><div class="public anchor" id="var-vann-annotated-objects"><h3>vann-annotated-objects</h3><div class="usage"><code>(vann-annotated-objects)</code></div><div class="doc"><pre class="plaintext">Returns `[obj, ...]
- Where:
  - `obj` bears metadata s.t. (get-ns-meta obj)  includes :vann/... annotations
    - these may be either namespaces or vars</pre></div></div></div></body></html>