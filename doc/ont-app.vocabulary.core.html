<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.vocabulary.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to vocabulary</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont-app</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vocabulary</span></div></div></li><li class="depth-3 branch current"><a href="ont-app.vocabulary.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="ont-app.vocabulary.format.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>format</span></div></a></li><li class="depth-3 branch"><a href="ont-app.vocabulary.linguistics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linguistics</span></div></a></li><li class="depth-3 branch"><a href="ont-app.vocabulary.lstr.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lstr</span></div></a></li><li class="depth-3"><a href="ont-app.vocabulary.wikidata.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wikidata</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-clear-caches.21"><div class="inner"><span>clear-caches!</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-all-ns"><div class="inner"><span>cljc-all-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-find-ns"><div class="inner"><span>cljc-find-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-find-prefixes"><div class="inner"><span>cljc-find-prefixes</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-get-ns-meta"><div class="inner"><span>cljc-get-ns-meta</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-ns-aliases"><div class="inner"><span>cljc-ns-aliases</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-ns-map"><div class="inner"><span>cljc-ns-map</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-cljc-put-ns-meta.21"><div class="inner"><span>cljc-put-ns-meta!</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-collect-prefixes"><div class="inner"><span>collect-prefixes</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-default-on-no-kwi-ns"><div class="inner"><span>default-on-no-kwi-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-default-on-no-ns"><div class="inner"><span>default-on-no-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-exceptional-iri-str-re"><div class="inner"><span>exceptional-iri-str-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-get-ns-meta"><div class="inner"><span>get-ns-meta</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-invalid-qname-name"><div class="inner"><span>invalid-qname-name</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-iri-for"><div class="inner"><span>iri-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-keyword-for"><div class="inner"><span>keyword-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-kwi-missing-namespace-if-not-urn-or-arn"><div class="inner"><span>kwi-missing-namespace-if-not-urn-or-arn</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-namespace-re"><div class="inner"><span>namespace-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-namespace-to-ns"><div class="inner"><span>namespace-to-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-ns-to-namespace"><div class="inner"><span>ns-to-namespace</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-ns-to-prefix"><div class="inner"><span>ns-to-prefix</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-on-duplicate-prefix"><div class="inner"><span>on-duplicate-prefix</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-ordinary-iri-str-re"><div class="inner"><span>ordinary-iri-str-re</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefix-re-str"><div class="inner"><span>prefix-re-str</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefix-to-namespace-uri"><div class="inner"><span>prefix-to-namespace-uri</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefix-to-ns"><div class="inner"><span>prefix-to-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prefixed-ns"><div class="inner"><span>prefixed-ns</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-prepend-prefix-declarations"><div class="inner"><span>prepend-prefix-declarations</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-put-ns-meta.21"><div class="inner"><span>put-ns-meta!</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-qname-for"><div class="inner"><span>qname-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-sparql-prefixes-for"><div class="inner"><span>sparql-prefixes-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-terms"><div class="inner"><span>terms</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-uri-for"><div class="inner"><span>uri-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-uri-str-for"><div class="inner"><span>uri-str-for</span></div></a></li><li class="depth-1"><a href="ont-app.vocabulary.core.html#var-vann-annotated-objects"><div class="inner"><span>vann-annotated-objects</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.vocabulary.core</h1><div class="doc"><pre class="plaintext">Defines utilities and a set of namespaces for commonly used linked data 
constructs, metadata of which specifies RDF namespaces, prefixes and other 
details.</pre></div><div class="public anchor" id="var-clear-caches.21"><h3>clear-caches!</h3><div class="usage"><code>(clear-caches!)</code></div><div class="doc"><pre class="plaintext">Side-effects: resets all caches in voc/ to nil
NOTE: call this when you may have imported new namespace metadata</pre></div></div><div class="public anchor" id="var-cljc-all-ns"><h3>cljc-all-ns</h3><div class="usage"><code>(cljc-all-ns)</code></div><div class="doc"><pre class="plaintext">Returns (`ns-name-or-obj` ...)
Where
  - `ns-name-or-obj` may either be a namespace (in clj) 
     or the name of a namespace (in cljs)</pre></div></div><div class="public anchor" id="var-cljc-find-ns"><h3>cljc-find-ns</h3><div class="usage"><code>(cljc-find-ns _ns)</code></div><div class="doc"><pre class="plaintext">Returns `ns-name-or-obj` for `_ns`, or nil.
Where 
  - `ns-name-or-obj` may either be a namespace (in clj) 
    or the name of a namespace (in cljs)
  - `_ns` is a symbol which may name a namespace.
NOTE: Implementations involving cljs must use cljs-put/get-ns-meta to declare
  ns metadata.</pre></div></div><div class="public anchor" id="var-cljc-find-prefixes"><h3>cljc-find-prefixes</h3><div class="usage"><code>(cljc-find-prefixes re-str s)</code></div><div class="doc"><pre class="plaintext">Returns #{`prefix`...} for `s`
Where
  - `prefix` is a prefix found in `s`, for which some (meta ns) has a 
     :vann/preferredNamespacePrefix declaration
  - `s` is a string, typically a SPARQL query body for which we want to 
    infer prefix declarations.</pre></div></div><div class="public anchor" id="var-cljc-get-ns-meta"><h3>cljc-get-ns-meta</h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated. Use get-ns-meta
</pre></div></div><div class="public anchor" id="var-cljc-ns-aliases"><h3>cljc-ns-aliases</h3><div class="usage"><code>(cljc-ns-aliases)</code></div><div class="doc"><pre class="plaintext">Returns {`alias` `ns`, ...}
Where
  - `alias` is a symbol
  - `ns` is its associated ns in the current lexical environment.
NOTE: cljs will require explicit maintenance of *alias-map*
This is really only necessary if you're importing a package
as some symbol other than the preferred prefix.</pre></div></div><div class="public anchor" id="var-cljc-ns-map"><h3>cljc-ns-map</h3><div class="usage"></div><div class="doc"><pre class="plaintext">mimics behavior of `ns-map` on cljs, but returns empty symbol-&gt;binding map
</pre></div></div><div class="public anchor" id="var-cljc-put-ns-meta.21"><h3>cljc-put-ns-meta!</h3><h4 class="deprecated">deprecated</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Deprecated. Use put-ns-meta!
</pre></div></div><div class="public anchor" id="var-collect-prefixes"><h3>collect-prefixes</h3><div class="usage"><code>(collect-prefixes acc next-ns)</code></div><div class="doc"><pre class="plaintext">Returns {`prefix` `namespace` ...} s.t. `next-ns` is included
Where
  - `prefix` is a prefix declared in the metadata of `next-ns`
  - `namespace` is a URI namespace declared for `prefix` in metadata of `next-ns`
  - `next-ns` is typically an element in a reduction sequence of ns's </pre></div></div><div class="public anchor" id="var-default-on-no-kwi-ns"><h3>default-on-no-kwi-ns</h3><div class="usage"><code>(default-on-no-kwi-ns kw)</code></div><div class="doc"><pre class="plaintext">Returns the name-string of `kw` if its name string is a typical URI or URN, otherwise throws a :NoIRIForKw error
Where
- `kw` is a keyword with no namespace.</pre></div></div><div class="public anchor" id="var-default-on-no-ns"><h3>default-on-no-ns</h3><div class="usage"><code>(default-on-no-ns _uri _keyword)</code></div><div class="doc"><pre class="plaintext">Returns the kwi normally appropriate for `_keyword` in cases where no ns can be matched, as is the case with say http://.....
</pre></div></div><div class="public anchor" id="var-exceptional-iri-str-re"><h3>exceptional-iri-str-re</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">A regex matching an IRI string which doesn't match the usual http//-ish scheme, such as urn:
</pre></div></div><div class="public anchor" id="var-get-ns-meta"><h3>get-ns-meta</h3><div class="usage"><code>(get-ns-meta _ns)</code><code>(get-ns-meta)</code></div><div class="doc"><pre class="plaintext">Returns `metadata` assigned to ns named `_ns`
Where
- `_ns` names a namespace or a 'dummy' namespace whose sole purpose is to hold metadata.
- `metadata` := {`key` `value`, ...}
- `key` is a keyword containing vocabulary metadata, e.g. :vann/preferredNamespacePrefix
</pre></div></div><div class="public anchor" id="var-invalid-qname-name"><h3>invalid-qname-name</h3><div class="usage"></div><div class="doc"><pre class="plaintext">fn [qname-name] -&gt; truthy if `qname-name` is not valid
Where
- `qname-name` is a string</pre></div></div><div class="public anchor" id="var-iri-for"><h3>iri-for</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Alias of uri-for
</pre></div></div><div class="public anchor" id="var-keyword-for"><h3>keyword-for</h3><div class="usage"><code>(keyword-for uri)</code><code>(keyword-for on-no-ns uri)</code></div><div class="doc"><pre class="plaintext">Returns a keyword equivalent of `uri`, properly prefixed if Vann declarations
exist in some ns in the current lexical environment.
Side effects per `on-no-ns`
Where
- `uri` is a string representing a URI
- `on-no-ns` (optional) := fn [uri kw] -&gt; kwi',
   possibly with side-effects in response to the fact that no qname was found for
   `uri` (default returns `kw`)
NOTE: typically `on-no-ns` would log a warning or make an assertion.
</pre></div></div><div class="public anchor" id="var-kwi-missing-namespace-if-not-urn-or-arn"><h3>kwi-missing-namespace-if-not-urn-or-arn</h3><div class="usage"><code>(kwi-missing-namespace-if-not-urn-or-arn kw)</code></div><div class="doc"><pre class="plaintext">Returns the name-stiring of `kw`, or throws ::NoIRIForKw if `kw` is incorrectly missing a namespace
</pre></div></div><div class="public anchor" id="var-namespace-re"><h3>namespace-re</h3><div class="usage"><code>(namespace-re)</code></div><div class="doc"><pre class="plaintext">Returns a regex to recognize substrings matching a URI for an ns 
declared with LOD metadata. Groups for namespace and value.</pre></div></div><div class="public anchor" id="var-namespace-to-ns"><h3>namespace-to-ns</h3><div class="usage"><code>(namespace-to-ns)</code></div><div class="doc"><pre class="plaintext">returns {`namespace` `ns` ...} for each `ns` with :vann/preferredNamespaceUri
declaration
Where
- `namespace` is the URI suitable for for an RDF prefix declaration
- `ns` is either a clojure ns (clj) or a symbol naming a clojure ns (cljs).</pre></div></div><div class="public anchor" id="var-ns-to-namespace"><h3>ns-to-namespace</h3><div class="usage"><code>(ns-to-namespace _ns)</code></div><div class="doc"><pre class="plaintext">Returns `iri` for `ns`
Where
  - `iri` is an iri declared with :vann/preferredNamespaceUri in the metadata for 
    `ns`, or nil
  - `ns` is an instance of clojure.lang.Namespace (in clj) or a symbol-name for ns (cljs)</pre></div></div><div class="public anchor" id="var-ns-to-prefix"><h3>ns-to-prefix</h3><div class="usage"><code>(ns-to-prefix _ns)</code></div><div class="doc"><pre class="plaintext">Returns the prefix associated with `_ns`
Where
  - `_ns` is a clojure namespace, which may have :vann/preferredNamespacePrefix
  declaration in its metadata.   </pre></div></div><div class="public anchor" id="var-on-duplicate-prefix"><h3>on-duplicate-prefix</h3><div class="usage"><code>(on-duplicate-prefix prefixes prefix _ns)</code></div><div class="doc"><pre class="plaintext">Throws an error if a prefix is bound to more than one namespace.
Reduces into `prefix` argument
NOTE: Can be overridden with `with-redefs`.</pre></div></div><div class="public anchor" id="var-ordinary-iri-str-re"><h3>ordinary-iri-str-re</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">An regex matching a standard IRI string like http://
</pre></div></div><div class="public anchor" id="var-prefix-re-str"><h3>prefix-re-str</h3><div class="usage"><code>(prefix-re-str)</code></div><div class="doc"><pre class="plaintext">Returns a regex string that recognizes prefixes declared in ns metadata with 
  `:vann/preferredNamespacePrefix` keys. 
NOTE: this is a string because the actual re-pattern will differ per clj/cljs.</pre></div></div><div class="public anchor" id="var-prefix-to-namespace-uri"><h3>prefix-to-namespace-uri</h3><div class="usage"><code>(prefix-to-namespace-uri prefix)</code></div><div class="doc"><pre class="plaintext">returns `namespace` URI associated with `prefix`
Where:
- `namespace` is a string declared for some `ns` with vann/preferredNamespaceUri
- `prefix` is a string declared for `ns` with vann/preferredNamespacePrefix
</pre></div></div><div class="public anchor" id="var-prefix-to-ns"><h3>prefix-to-ns</h3><div class="usage"><code>(prefix-to-ns)</code></div><div class="doc"><pre class="plaintext">Returns {`prefix` `ns` ...}
Where 
  - `prefix` is declared in metadata for some `ns` with 
  :vann/preferredNamespacePrefix 
  - `ns` is an instance of clojure.lang.ns available within the lexical 
  context in which the  call was made.</pre></div></div><div class="public anchor" id="var-prefixed-ns"><h3>prefixed-ns</h3><div class="usage"><code>(prefixed-ns prefix)</code></div><div class="doc"><pre class="plaintext">Returns nil or the ns whose `prefix` was declared in metadata with
  :vann/preferredNamespacePrefix
Where
  - `prefix` is a string, typically parsed from a keyword.</pre></div></div><div class="public anchor" id="var-prepend-prefix-declarations"><h3>prepend-prefix-declarations</h3><div class="usage"><code>(prepend-prefix-declarations sparql-string)</code></div><div class="doc"><pre class="plaintext">Returns `sparql-string`, prepended with appropriate PREFIX decls.
</pre></div></div><div class="public anchor" id="var-put-ns-meta.21"><h3>put-ns-meta!</h3><div class="usage"><code>(put-ns-meta! _ns m)</code><code>(put-ns-meta! m)</code></div><div class="doc"><pre class="plaintext">Side-effect: ensures that subsequent calls to (cljc-get-ns-meta `_ns` return `m`
Where
- `_ns`  is an ns(clj only) or the name of a namespace, possibly declared for the sole purpose of holding vocabulary metadata (e.g. rdf, foaf, etc)
- `m` := {`key` `value`, ...}, metadata (clj) or 'pseudo-metadata' (cljs)
- `key` is a keyword containing vocabulary metadata, e.g.
  `::vann/preferredNamespacePrefix`
NOTE: In cljs, ns's are not available at runtime, so the metadata is stored
  in an atom called 'voc/cljs-ns-metadata'
See also declarations for ont-app.vocabulary.rdf, ont-app.vocabulary.foaf, etc.
for examples of namespaces declared solely to hold vocabulary metadata.
</pre></div></div><div class="public anchor" id="var-qname-for"><h3>qname-for</h3><div class="usage"><code>(qname-for kw)</code></div><div class="doc"><pre class="plaintext">Returns the 'qname' URI for `kw`, or &lt;...&gt;'d full URI if no valid qname
  could be found. Throws an error if the prefix is specified, but can't be
  mapped to metadata.
Where
  - `kw` is a keyword, in a namespace with LOD declarations in its metadata.</pre></div></div><div class="public anchor" id="var-sparql-prefixes-for"><h3>sparql-prefixes-for</h3><div class="usage"><code>(sparql-prefixes-for sparql-string)</code></div><div class="doc"><pre class="plaintext">Returns [`prefix-string`...] for each prefix identified in `sparql-string`
Where
  - `prefix-string` := PREFIX `prefix`: `namespace`

  - `prefix` is a prefix defined for `namespace` in metadata of some ns with 
     `:vann/preferredNamespacePrefix`
  - `namespace` is a namespace defined in the metadata for some ns with 
    `:vann/preferredNamespaceUri`</pre></div></div><div class="public anchor" id="var-terms"><h3>terms</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Describes vocabulary for this namespace. May be read into an IGraph downstream.
</pre></div></div><div class="public anchor" id="var-uri-for"><h3>uri-for</h3><div class="usage"><code>(uri-for kw)</code><code>(uri-for on-no-kwi-ns kw)</code></div><div class="doc"><pre class="plaintext">Returns `iri`  for `kw` based on metadata attached to `ns` Alias of `iri-for` or `on-no-prefix (kw) if the keyword is not namespaced.
Where
  - `iri` is of the form `namespace``value`
  - `kw` is a keyword of the form `prefix`:`value`
  - `ns` is an instance of clojure.lang.ns
  - `on-no-kwi-ns` := fn [kw] -&gt; uri, for cases where `kw` is not namespaced
    default is `default-on-no-kwi-ns`
  - `prefix` is declared with :vann/preferredNamespacePrefix in metadata of `ns`
  - `namespace` is typically of the form http://...., declared with 
    `:vann/preferredNamespaceUri` in metadata of `ns`</pre></div></div><div class="public anchor" id="var-uri-str-for"><h3>uri-str-for</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns a proper URI string for some value, dispatched on type.
</pre></div></div><div class="public anchor" id="var-vann-annotated-objects"><h3>vann-annotated-objects</h3><div class="usage"><code>(vann-annotated-objects)</code></div><div class="doc"><pre class="plaintext">Returns `[obj, ...]
Where:
  - `obj` bears metadata s.t. (get-ns-meta obj)  includes :vann/... annotations
    - these may be either namespaces or vars</pre></div></div></div></body></html>